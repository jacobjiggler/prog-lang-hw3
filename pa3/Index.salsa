
module pa3;

import java.util.HashMap;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Map;
import java.nio.charset.Charset;
import java.io.BufferedWriter;
import java.nio.file.Files;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

behavior Index {
	
	int doc_num = 0;
	int worker_num = 0;

    void act(String[] argv) {
        // get number of documents and workers
        this.doc_num = Integer.parseInt(argv[2]);
        this.worker_num = Integer.parseInt(argv[3]);

		if (doc_num == 0 || worker_num == 0)
			return;
        // grab all the documents
        token workers = create_workers(argv[0]);

        // compute tfs based on frequency
        //token tfs = compute_tfs(workers);

        // Create a treemap of idfs 
        //token idfs = compute_idf(freqs);

        // Grab a super long string of the terms and idfs values
        //token output = output_terms(idfs, all_docs);

        // save to text files
        //write_output(output, argv[1]);
    }

    // Create a new worker for each document
    Doc_Reader[] create_workers(String folder) {

    // Create the worker objects
		Doc_Reader[] workers = new Doc_Reader[this.worker_num];
	join {
		for (int i = 0; i < this.worker_num; ++i) {
			workers[i] = new Doc_Reader();
			workers[i] <- setDocLimit(doc_num/worker_num + 1); 
		}
	} @ output(token);
	
	//loop through both workers and docs distributing the docs between the workers
	
	int worker_itr = 0;
	join{
		for (int i = 0; i < doc_num; i++){
			if (worker_itr >= worker_num)
				worker_itr = 0;
			workers[worker_itr]<- parsedoc(Paths.get(folder, Integer.toString(i) + ".txt").toString());
			worker_itr++;
		}
	} @  output(token) @ currentContinuation;
	}
	
	
	//Why does ithe language require this? I'm not even using the output
	Object[] output(Object[] objs){
		return objs;
		}
	// Getting the idf values
	double idf(int value, int N) {
        return Math.log10(((double)(N + 2)) / ((double)(1 + value))); 
    }
}
